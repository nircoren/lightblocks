1. key based lock instead of obj based lock (map of locks?) somthing like
	type SafeStruct struct {
		mu       sync.Mutex
		value    map[string]interface{}
		keyLocks map[string]*sync.RWMutex
	}

	func NewSafeStruct() *SafeStruct {
		return &SafeStruct{
			value:    make(map[string]interface{}),
			keyLocks: make(map[string]*sync.RWMutex),
		}
	}

	func (s *SafeStruct) getKeyLock(key string) *sync.RWMutex {
		s.mu.Lock()
		defer s.mu.Unlock()

		// If the key doesn't have a lock yet, create one
		if _, exists := s.keyLocks[key]; !exists {
			s.keyLocks[key] = &sync.RWMutex{}
		}

		return s.keyLocks[key]
	}
2. 